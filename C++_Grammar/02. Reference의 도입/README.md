# [C++ 레퍼런스(reference, 참조자)의 도입](https://modoocode.com/141)

## 참조자의 도입

```C++
#include <iostream>

int change_val(int *p) {
  *p = 3;

  return 0;
}
int main() {
  int number = 5;

  std::cout << number << std::endl;
  change_val(&number);
  std::cout << number << std::endl;
}
```

위 코드의 실행결과는 무엇일까요?

결과는
```
5
3
```
입니다. C 언어를 배우신 분이라면 위 코드를 무리없이 이해하실 수 있을 것입니다.

`change_val` 함수의 인자 `p` 에 `number의 주소값`을 전달하여, `*p` 를 통해 `number` 를 참조하여 `number` 의 값을 `3`으로 바꾸었습니다.

C 언어에서는 어떠한 변수를 가리키고 싶을 땐 반드시 포인터를 사용해야만 했습니다. 그런데 C++ 에서는 다른 변수나 상수를 가리키는 방법으로 또 다른 방식을 제공하는데, 이를 바로 참조자(레퍼런스 - reference) 라고 부릅니다.


```C++
#include <iostream>

int main() {
  int a = 3;
  int& another_a = a;

  another_a = 5;
  std::cout << "a : " << a << std::endl;
  std::cout << "another_a : " << another_a << std::endl;

  return 0;
}
```

성공적으로 컴파일 하였다면
```
a : 5
another_a : 5
```
와 같이 나옵니다.

```
int a = 3;
```
먼저 우리는 위와 같이 간단히 int 형 변수인 `a` 를 정의하였고 그 안에 `3` 이란 값을 넣어주었습니다.

```
int& another_a = a;
```
그 후에 우리는 `a` 의 참조자 `another_a` 를 정의하였습니다. 이 때 참조자를 정하는 방법은, 가리키고자 하는 타입 뒤에 `&` 를 붙이면 됩니다.

위 처럼 int 형 변수의 참조자를 만들고 싶을 때에는 `int&` 를, double 의 참조자를 만드려면 `double&` 로 하면 됩니다. 심지어 int* 와 같은 포인터 타입의 참조자를 만드려면 `int*&` 로 쓰면 됩니다.

위와 같이 선언함으로써 우리는 `another_a` 는 `a` 의 참조자다! 라고 공표하게 되었습니다. 이 말은 즉슨 `another_a` 는 `a` 의 또다른 이름 이라고 컴파일러에게 알려주는 것입니다. 따라서 `another_a` 에 어떠한 작업을 수행하든 이는 **사실상 `a` 에 그 작업을 하는 것과 마찬가지** 입니다.

```C++
another_a = 5;
std::cout << "a : " << a << std::endl;
std::cout << "another_a : " << another_a << std::endl;
```
따라서 위 처럼 `another_a` 에 `5` 를 대입하였지만 실제로 `a` 의 값을 확인해보면 `5` 로 바뀌었음을 확인할 수 있습니다.

어떻게 보면 참조자와 포인터는 상당히 유사한 개념입니다. 포인터 역시 다른 어떤 변수의 주소값을 보관함으로써 해당 변수에 간접적으로 연산을 수행할 수 있기 때문이죠. 하지만 레퍼런스와 포인터는 몇 가지 중요한 차이점이 있습니다.

### 1) 레퍼런스는 반드시 처음에 누구의 별명이 될 것인지 지정해야 합니다.
레퍼런스는 정의 시에 반드시 누구의 별명인지 명시 해야 합니다. 따라서
```C++
int& another_a;
```
와 같은 문장은 불가능 합니다. 반면의 포인터의 경우
```C++
int* p;
```
는 전혀 문제가 없는 코드 입니다.

### 2) 레퍼런스가 한 번 별명이 되면 절대로 다른 이의 별명이 될 수 없다.
레퍼런스의 또 한 가지 중요한 특징으로 한 번 어떤 변수의 참조자가 되버린다면, 이 더이상 다른 변수를 참조할 수 없게 됩니다.

학창시절 별명이 무덤까지 가는 것과 비슷하다고 보시면 됩니다 :)

예를 들어서 아래와 같은 코드를 살펴봅시다. 
```C++
int a = 10;
int &another_a = a; // another_a 는 이제 a 의 참조자!

int b = 3;
another_a = b; // ?? 
```
마지막에 `another_a = b;` 문장은 어떤 의미 일까요? `another_a` 보고 다른 변수인 `b` 를 가리키라고 하는 것일까요? 아닙니다! 이는 그냥 `a` 에 `b` 의 값을 대입하라는 의미 입니다. 앞서 말했듯이 `another_a` 에 무언가를 하는 것은 사실상 `a` 에 무언가를 하는 것과 동일하다고 했으므로 이 문장은 그냥 `a = b` 와 동치 입니다.

참고로
```C++
&another_a = b;
```
요건 어떤가요? 라고 물어보실 수 도 있는데 위 문장은 그냥 `&a = b;` 가 되어서 말이 안되는 문장이 됩니다.

반면에 포인터는 어떨까요.

 C/C++ 확대 축소
int a = 10;
int* p = &a; // p 는 a 를 가리킨다.

int b = 3;
p = &b // 이제 p 는 a 를 버리고 b 를 가리킨다
위와 같이 누구를 가리키는지 자유롭게 바뀔 수 있습니다.

레퍼런스는 메모리 상에 존재하지 않을 수 도 있다.
포인터의 경우를 생각해봅시다. 우리가 아래와 같이 포인터 p 를 정의 한다면

 C/C++ 확대 축소
int a = 10;
int* p = &a;  // p 는 메모리 상에서 당당히 8 바이트를 차지하게 됩니다.
p 는 당당히 메모리 상에서 8 바이트를 차지하는 녀석이 됩니다 (물론 32 비트 시스템에서는 4바이트 겠죠!) 그런데 레퍼런스의 경우를 생각해봅시다.

 C/C++ 확대 축소
int a = 10;
int &another_a = a; // another_a 가 자리를 차지할 필요가 있을까?
만일 내가 컴파일러라면 another_a 위해서 메모리 상에 공간을 할당할 필요가 있을까요? 아니죠! 왜냐하면 another_a 가 쓰이는 자리는 모두 a 로 바꿔치기 하면 되니까요. 따라서 이 경우 레퍼런스는 메모리 상에 존재하지 않게 됩니다. 물론 그렇다고 해서 항상 존재하지 않은 것은 아닙니다. 아래 예제를 보실까요.

